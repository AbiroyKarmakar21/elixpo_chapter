
from typing import Optional
from boson_multimodal.serve.serve_engine import HiggsAudioServeEngine
from fastapi import HTTPException
from utility import set_random_seed
from loguru import logger
from config import DEFAULT_STOP_STRINGS, SAMPLE_RATE
import traceback 
import torch
import io
import torchaudio
import os

higgs_engine: Optional[HiggsAudioServeEngine] = None


async def synthesize_speech(
    chattemplate,
    reqID,
    seed: Optional[int] = None,
    temp_audio_path: Optional[str] = None
) -> bytes:
    if higgs_engine is None:
        raise HTTPException(status_code=500, detail="TTS engine not initialized")
    try:
        temperature: float = 0.7,
        top_p: float = 0.95,
        top_k: int = 50,
        set_random_seed(seed)
        try:
            response = higgs_engine.generate(
                chat_ml_sample=chattemplate,
                max_new_tokens=1024,
                temperature=temperature,
                top_k=top_k if top_k > 0 else None,
                top_p=top_p,
                stop_strings=DEFAULT_STOP_STRINGS,
                ras_win_len=7,
                ras_win_max_num_repeat=2,
                force_audio_gen=True
            )
        except Exception as gen_error:
            logger.error(f"Generation error: {gen_error}")
            logger.error(f"Generation traceback: {traceback.format_exc()}")
            logger.info("Retrying with minimal parameters...")
            response = higgs_engine.generate(
                chat_ml_sample=chattemplate,
                max_new_tokens=512,
                temperature=0.8,
                force_audio_gen=True
            )
        if response.audio is None:
            raise HTTPException(status_code=500, detail="No audio generated by model")
        audio_tensor = torch.from_numpy(response.audio).unsqueeze(0)
        if hasattr(response, 'sampling_rate'):
            sample_rate = response.sampling_rate
        else:
            sample_rate = SAMPLE_RATE
        buffer = io.BytesIO()
        torchaudio.save(buffer, audio_tensor, sample_rate, format="WAV")
        audio_bytes = buffer.getvalue()
        logger.info(f"Generated audio: {len(audio_bytes)} bytes at {sample_rate}Hz")
        return audio_bytes
    except Exception as e:
            logger.error(f"Synthesis error: {traceback.format_exc()}")
            raise HTTPException(status_code=500, detail=f"Synthesis failed: {str(e)}")
    finally:
        if temp_audio_path:
            try:
                os.remove(temp_audio_path)
                logger.info(f"Temporary audio file {temp_audio_path} cleaned up")
            except Exception as cleanup_error:
                logger.error(f"Failed to clean up temporary audio file: {cleanup_error}")

    