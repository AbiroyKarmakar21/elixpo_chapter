import os
import io
import json
import time
import traceback
from typing import Optional
from urllib.parse import unquote
import numpy as np
import torch
import sys
from flask import Flask, request, jsonify, Response, g, after_this_request
from flask_cors import CORS
from loguru import logger
from boson_multimodal.serve.serve_engine import HiggsAudioServeEngine
from config import MODEL_PATH, AUDIO_TOKENIZER_PATH, MAX_FILE_SIZE_MB
from utility import download_audio, validate_and_decode_base64_audio, save_temp_audio, encode_audio_base64
from synthesis import synthesize_speech
from requestID import RequestIDMiddleware, reqID
from templates import create_speaker_chat

if torch.cuda.is_available():
    device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
    print(f"✅ Using GPU: {torch.cuda.get_device_name(device)}")
else:
    device = torch.device("cpu")
    print("⚠️ CUDA not available, using CPU instead.")

app = Flask(__name__)
CORS(app)

higgs_engine = None

@app.before_first_request
def startup_event():
    global higgs_engine
    try:
        logger.info(f"Initializing Higgs Audio V2 on {device}...")
        higgs_engine = HiggsAudioServeEngine(
            model_name_or_path=MODEL_PATH,
            audio_tokenizer_name_or_path=AUDIO_TOKENIZER_PATH,
            device=device
        )
        logger.info("✅ Higgs Audio V2 initialized successfully")
    except Exception as e:
        logger.error(f"❌ Failed to initialize Higgs: {e}")
        logger.error(f"Initialization traceback: {traceback.format_exc()}")

@app.before_request
def before_request():
    g.request_id = reqID()
    g.start_time = time.time()

@app.after_request
def after_request(response):
    process_time = time.time() - g.get('start_time', time.time())
    response.headers["X-Process-Time"] = str(process_time)
    return response

@app.route("/", methods=["GET"])
def health_check():
    return jsonify({
        "status": "healthy",
        "model": "higgs-v2",
        "device": str(device),
        "engine_loaded": higgs_engine is not None,
        "max_audio_size_mb": MAX_FILE_SIZE_MB,
        "request_id": g.request_id,
        "endpoints": {
            "get": "/ssget?text=your_text_here&audio=base64_or_url&system=optional_system_prompt&seed=optional_seed",
            "post": "/sspost"
        }
    })

@app.route("/ssget", methods=["GET"])
def singleSpeakerInference():
    try:
        text = request.args.get("text")
        audio = request.args.get("audio")
        system = request.args.get("system")
        seed = request.args.get("seed", type=int)
        requestID = g.request_id
        reference_audio_data = None
        tmp = None

        if text is None:
            return jsonify({"error": {"message": "Missing required 'text' parameter.", "type": "invalid_request_error", "code": 400}}), 400

        if system and len(system) > 500:
            return jsonify({"error": {"message": "The 'system' parameter must not exceed 500 characters.", "type": "invalid_request_error", "code": 400}}), 400

        if audio:
            is_audio_url = audio.startswith("http://") or audio.startswith("https://")
            if not is_audio_url:
                return jsonify({"error": {"message": f"Invalid audio data: {audio}", "type": "invalid_request_error", "code": 400}}), 400
            if is_audio_url:
                audio_data = download_audio(audio)
                convertBase64 = encode_audio_base64(audio_data)
                reference_audio_data = validate_and_decode_base64_audio(convertBase64)
                tmp = save_temp_audio(reference_audio_data, requestID)

                

        # template = create_speaker_chat(text, requestID, system, reference_audio_data, tmp)
        # audio_data = synthesize_speech(template, temp_audio_path=tmp, seed=seed)
        # if not audio_data:
        #     return jsonify({"error": {"message": "No audio generated by model", "type": "internal_error", "code": 500}}), 500
        # else:
        #     logger.info(f"Generated audio for request {requestID}")

        # return Response(
        #     audio_data,
        #     mimetype="audio/wav",
        #     headers={
        #         "Content-Disposition": "inline; filename=speech.wav",
        #         "Content-Length": str(len(audio_data))
        #     }
        # )

    except Exception as e:
        logger.error(f"GET TTS error: {traceback.format_exc()}")
        return jsonify({"error": {"message": str(e), "type": "internal_error", "code": 500}}), 500

@app.route("/sspost", methods=["POST"])
def singleSpeakerInferencePost():
    try:
        body = request.get_json(force=True)
        messages = body.get("messages", [])
        if not messages or not isinstance(messages, list):
            return jsonify({"error": {"message": "Missing or invalid 'messages' in payload.", "type": "invalid_request_error", "code": 400}}), 400

        message = messages[0]
        content = message.get("content", [])
        if not content or not isinstance(content, list):
            return jsonify({"error": {"message": "Missing or invalid 'content' in message.", "type": "invalid_request_error", "code": 400}}), 400

        text = None
        audio = None
        audio_text = None
        system = None
        reference_audio_data = None
        tmp = None

        for item in content:
            if item.get("type") == "text":
                if message.get("role") == "system":
                    system = item.get("text")
                else:
                    text = item.get("text")
            elif item.get("type") == "input_audio":
                audio = item.get("audio", {}).get("data")
            elif item.get("type") == "audio_text":
                audio_text = item.get("audio_text")

        if text is None:
            return jsonify({"error": {"message": "Missing required 'text' in content.", "type": "invalid_request_error", "code": 400}}), 400

        if audio:
            is_audio_url = isinstance(audio, str) and (audio.startswith("http://") or audio.startswith("https://"))
            if is_audio_url:
                audio_data = download_audio(audio)
                convertBase64 = encode_audio_base64(audio_data)
                reference_audio_data = validate_and_decode_base64_audio(convertBase64)
                tmp = save_temp_audio(reference_audio_data, g.request_id)
            else:
                reference_audio_data = validate_and_decode_base64_audio(audio)
                tmp = save_temp_audio(reference_audio_data, g.request_id)

        template = create_speaker_chat(text, g.request_id, system, reference_audio_data, tmp, audio_text)
        audio_data = synthesize_speech(template, temp_audio_path=tmp)
        if not audio_data:
            return jsonify({"error": {"message": "No audio generated by model", "type": "internal_error", "code": 500}}), 500
        else:
            logger.info(f"Generated audio for request {g.request_id}")

        return Response(
            audio_data,
            mimetype="audio/wav",
            headers={
                "Content-Disposition": "inline; filename=speech.wav",
                "Content-Length": str(len(audio_data))
            }
        )

    except Exception as e:
        logger.error(f"POST TTS error: {traceback.format_exc()}")
        return jsonify({"error": {"message": str(e), "type": "internal_error", "code": 500}}), 500

@app.errorhandler(400)
def bad_request(e):
    return jsonify({"error": {"message": str(e), "type": "invalid_request_error", "code": 400}}), 400

@app.errorhandler(500)
def internal_error(e):
    logger.error(f"Unhandled exception: {traceback.format_exc()}")
    return jsonify({"error": {"message": "Internal server error", "type": "internal_error", "code": 500}}), 500

if __name__ == "__main__":
    host = "127.0.0.1"
    port = 8000
    postJSON = """
        "messages": [
            {
                "role" : "system",
                "content" : [
                    {"type" : "text", "text" : "System instructions here"}
                ]
            },
            {
                "role": "user",
                "content": [
                    { "type": "text", "text": "Your prompt text here" },
                    {
                    "type": "input_audio",
                    "audio": { "data": "<base64_audio_string>", "format": "wav" }
                    },
                    {
                    "type": "audio_text",
                    "audio_text": "Transcription or description of the reference audio"
                    }
                ]
                }
        ]
    """
    logger.info(f"Starting Higgs V2 API Server")
    logger.info(f"Host: {host}:{port}")
    logger.info(f"Device: {device}")
    logger.info(f"Max audio size: {MAX_FILE_SIZE_MB}MB")
    logger.info(f"GET endpoint: http://{host}:{port}/ssget?text=your_text_here&audio=base64_or_url&system=optional_system_prompt&seed=optional_seed")
    logger.info(f"POST endpoint: http://{host}:{port}/sspost  expects json payload like {postJSON}")

    app.run(host=host, port=port, debug=True)