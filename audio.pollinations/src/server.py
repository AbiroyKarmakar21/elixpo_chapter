import os
import io
import json
import time
import traceback
from typing import Optional
from urllib.parse import unquote
import numpy as np
import torch
import sys
import uvicorn
from fastapi import FastAPI, HTTPException, Request, Response, Path
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
from loguru import logger
from boson_multimodal.serve.serve_engine import HiggsAudioServeEngine
from config import MODEL_PATH, AUDIO_TOKENIZER_PATH, MAX_FILE_SIZE_MB
from pydanticModels import APIMessage, OpenAIRequest
from utility import download_audio, validate_and_decode_base64_audio, save_temp_audio
from synthesis import synthesize_speech
from requestID import RequestIDMiddleware, reqID



from templates import create_speaker_chat

device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
app = FastAPI(
    title="Higgs V2 Audio API",
    description="OpenAI-compatible TTS API with voice cloning",
    version="2.0.2"
)
app.add_middleware(
    CORSMiddleware,
    RequestIDMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

app.on_event("startup")
async def startup_event():
    global higgs_engine
    try:
        logger.info(f"Initializing Higgs Audio V2 on {device}...")
        higgs_engine = HiggsAudioServeEngine(
            model_name_or_path=MODEL_PATH,
            audio_tokenizer_name_or_path=AUDIO_TOKENIZER_PATH,
            device=device
        )
        logger.info("✅ Higgs Audio V2 initialized successfully")
    except Exception as e:
        logger.error(f"❌ Failed to initialize Higgs: {e}")
        logger.error(f"Initialization traceback: {traceback.format_exc()}")




@app.get("/")
async def health_check(request: Request):
    requestID : str = getattr(request.state, "request_id", reqID())
    return {
        "status": "healthy",
        "model": "higgs-v2",
        "device": str(device),
        "engine_loaded": higgs_engine is not None,
        "max_audio_size_mb": MAX_FILE_SIZE_MB,
        "request_id": requestID,
        "endpoints": {
            "get": "/{text}?model=higgs&seed=123&audio=base64_or_url",
            "post": "/openai"
        }
    }

@app.api_route("/ssget", methods=["GET"])
async def singleSpeakerInference(
    request: Request,
    text: str = None,
    audio: Optional[str] = None,
    system: Optional[str] = None,
    seed: Optional[int] = None
):
    try:
        requestID : str = getattr(request.state, "request_id", reqID())
        reference_audio_data = None
        tmp = None

        if text is None:
            raise HTTPException(status_code=400, detail="Missing required 'text' parameter.")

        if system and len(system) > 500:
            raise HTTPException(status_code=400, detail="The 'system' parameter must not exceed 500 characters.")

        if audio:
            is_audio_url = audio.startswith("http://") or audio.startswith("https://")
            if not is_audio_url:
                raise HTTPException(status_code=400, detail=f"Invalid audio data: {audio}")
            if is_audio_url:
                audio = await download_audio(audio)
                reference_audio_data = validate_and_decode_base64_audio(audio)
                tmp = save_temp_audio(reference_audio_data, requestID)

        template = create_speaker_chat(text, requestID, system, reference_audio_data, tmp)
        audio_data = await synthesize_speech(template, temp_audio_path=tmp, seed=seed)
        if not audio_data:
            raise HTTPException(status_code=500, detail="No audio generated by model")
        else:
            logger.info(f"Generated audio for request {requestID}")

        return Response(
            content=audio_data,
            media_type="audio/wav",
            headers={
                "Content-Disposition": "inline; filename=speech.wav",
                "Content-Length": str(len(audio_data))
            }
        )

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"GET TTS error: {traceback.format_exc()}")
        raise HTTPException(status_code=500, detail=str(e))



@app.post("/sspost", methods=["POST"])
async def singleSpeakerInferencePost(request: Request):
    try:
        requestID: str = getattr(request.state, "request_id", reqID())
        body = await request.json()
        messages = body.get("messages", [])
        if not messages or not isinstance(messages, list):
            raise HTTPException(status_code=400, detail="Missing or invalid 'messages' in payload.")

        message = messages[0]
        content = message.get("content", [])
        if not content or not isinstance(content, list):
            raise HTTPException(status_code=400, detail="Missing or invalid 'content' in message.")

        text = None
        audio = None
        audio_text = None
        system = None
        reference_audio_data = None
        tmp = None

        for item in content:
            if item.get("type") == "text":
                # Accept both user and system role text
                if message.get("role") == "system":
                    system = item.get("text")
                else:
                    text = item.get("text")
            elif item.get("type") == "input_audio":
                audio = item.get("audio", {}).get("data")
            elif item.get("type") == "audio_text":
                audio_text = item.get("audio_text")

        if text is None:
            raise HTTPException(status_code=400, detail="Missing required 'text' in content.")

        if audio:
            is_audio_url = isinstance(audio, str) and (audio.startswith("http://") or audio.startswith("https://"))
            if is_audio_url:
                audio_data = await download_audio(audio)
                reference_audio_data = validate_and_decode_base64_audio(audio_data)
                tmp = save_temp_audio(reference_audio_data, requestID)
            else:
                reference_audio_data = validate_and_decode_base64_audio(audio)
                tmp = save_temp_audio(reference_audio_data, requestID)

        template = create_speaker_chat(text, requestID, system, reference_audio_data, tmp, audio_text)
        audio_data = await synthesize_speech(template, temp_audio_path=tmp)
        if not audio_data:
            raise HTTPException(status_code=500, detail="No audio generated by model")
        else:
            logger.info(f"Generated audio for request {requestID}")

        return Response(
            content=audio_data,
            media_type="audio/wav",
            headers={
                "Content-Disposition": "inline; filename=speech.wav",
                "Content-Length": str(len(audio_data))
            }
        )

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"POST TTS error: {traceback.format_exc()}")
        raise HTTPException(status_code=500, detail=str(e))



@app.exception_handler(HTTPException)
async def http_exception_handler(request: Request, exc: HTTPException):
    return JSONResponse(
        status_code=exc.status_code,
        content={
            "error": {
                "message": exc.detail,
                "type": "invalid_request_error",
                "code": exc.status_code
            }
        }
    )

@app.exception_handler(Exception)
async def general_exception_handler(request: Request, exc: Exception):
    logger.error(f"Unhandled exception: {traceback.format_exc()}")
    return JSONResponse(
        status_code=500,
        content={
            "error": {
                "message": "Internal server error",
                "type": "internal_error",
                "code": 500
            }
        }
    )

@app.middleware("http")
async def add_process_time_header(request: Request, call_next):
    start_time = time.time()
    response = await call_next(request)
    process_time = time.time() - start_time
    response.headers["X-Process-Time"] = str(process_time)
    return response



if __name__ == "__main__":
    
    host = "127.0.0.1"
    port = 8000
    postJSON = """
        "messages": [
            {
                "role" : "system",
                "content" : [
                    {"type" : "text", "text" : "System instructions here"}
                ]
            },
            {
                "role": "user",
                "content": [
                    { "type": "text", "text": "Your prompt text here" },
                    {
                    "type": "input_audio",
                    "audio": { "data": "<base64_audio_string>", "format": "wav" }
                    },
                    {
                    "type": "audio_text",
                    "audio_text": "Transcription or description of the reference audio"
                    }
                ]
                }
        ]

    """
    logger.info(f"Starting Higgs V2 API Server")
    logger.info(f"Host: {host}:{port}")
    logger.info(f"Device: {device}")
    logger.info(f"Max audio size: {MAX_FILE_SIZE_MB}MB")
    logger.info(f"GET endpoint: http://{host}:{port}/ssget?text=your_text_here&audio=base64_or_url&system=optional_system_prompt&seed=optional_seed")
    logger.info(f"POST endpoint: http://{host}:{port}/sspost  expects json payload like {postJSON}")

    uvicorn.run(
        app,
        host=host,
        port=port,
        loop="uvloop",
        log_level="info"
    )